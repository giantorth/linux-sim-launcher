#!/usr/bin/env python3

from os.path import join, isfile, isdir, abspath, expanduser, dirname
from pathlib import Path
from os import makedirs, mkdir, environ, remove
from sys import argv, stdout
from urllib.request import urlopen, urlretrieve
from urllib.error import URLError
from shutil import which, rmtree
from subprocess import Popen, PIPE, DEVNULL
import json
import argparse
import logging
from datetime import datetime
import signal
import os
import subprocess
import time

# --- Logging Setup ---
def setup_logging(debug_enabled):
    logger = logging.getLogger("sim-launcher")
    logger.setLevel(logging.DEBUG if debug_enabled else logging.INFO)

    # Console Handler
    c_handler = logging.StreamHandler(stdout)
    c_format = logging.Formatter('[sim-launcher] %(levelname)s: %(message)s')
    c_handler.setFormatter(c_format)
    logger.addHandler(c_handler)

    if debug_enabled:
        # File Handler: log_timestamp.log in program folder
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_filename = join(LAUNCHERHOME, f"log_{timestamp}.log")
        f_handler = logging.FileHandler(log_filename)
        f_format = logging.Formatter('%(asctime)s - [sim-launcher] %(levelname)s: %(message)s')
        f_handler.setFormatter(f_format)
        logger.addHandler(f_handler)
        logger.info(f"Debug logging enabled. Writing to {log_filename}")

    return logger

# Global logger placeholder
log = None

def panic(msg):
    log.critical(msg)
    exit(-1)

def error(msg):
    log.error(msg)

def info(msg):
    log.info(msg)

def getenv(name, default=None):
    try:
        return environ[name]
    except KeyError:
        if default is not None:
            return default
        panic("environment variable " + name + " not found")

APPIDSIG = "AppId="
APPHOME = getenv("HOME") if not isfile("/.flatpak-info") else join(getenv("HOME"), ".var/app/com.valvesoftware.Steam")
LAUNCHERHOME = join(APPHOME, ".local/share/sim-launcher")
OPENTRACKURL = "http://api.github.com/repos/opentrack/opentrack/releases/latest"
SIMHUBURL = "https://github.com/SHWotever/SimHub/releases/tag/latest"
SIMHUB_DEFAULT_PFX = expanduser("~/.local/share/Steam/steamapps/compatdata")
SIMSHM = join( APPHOME, "git/simshmbridge/assets/" )
ACSIMSHM = join( APPHOME, "git/simshmbridge/assets/acshm" )
ACSIMSHMBRIDGE = join( APPHOME, "git/simshmbridge/assets/acbridge.exe" )
PC2SIMSHM = join( APPHOME, "git/simshmbridge/assets/pcars2shm" )
PC2SIMSHMBRIDGE = join( APPHOME, "git/simshmbridge/assets/pcars2bridge.exe" )
PROTONBRIDGE = ""
ZIPBINARY = ""

# Command line arguments
parser = argparse.ArgumentParser(description='Launch Steam games with optional OpenTrack and SimHub')
parser.add_argument('--opentrack', action='store_true', help='Launch OpenTrack')
parser.add_argument('--simhub', action='store_true', help='Launch SimHub')
parser.add_argument('--simhub-pfx', default=SIMHUB_DEFAULT_PFX, help='Path to Steam pfx for SimHub')
parser.add_argument('--simhub-exe', default="SimHubWPF.exe", help='SimHub executable name')
parser.add_argument('--simhub-appid', default="2825720939", help='SimHub Steam AppID')
parser.add_argument('--monocoque', action='store_true', help='Launch Monocoque')
parser.add_argument('--lookpilot', action='store_true', help='Launch LookPilot (Steam AppID: 3326890)')
parser.add_argument('--acbridge', action='store_true', help='Launch AC/ACC/ACE/ACR bridge')
parser.add_argument('--pc2bridge', action='store_true', help='Launch Project Cars 2/Automobilista 2 bridge')
parser.add_argument('--debug', action='store_true', help='Log output to log_timestamp.log in program folder')
args, unknown_args = parser.parse_known_args()

# Initialize Logger
log = setup_logging(args.debug)

# Restore original argv for Steam compatibility
# Note: Keep sys.argv assignment to maintain compatibility with findappid logic
argv_original = argv[:1] + unknown_args

def findappid():
    appid = ""
    for arg in argv_original:
        if APPIDSIG in arg:
            appid = arg[len(APPIDSIG):]
    if appid == "":
        error("appid not found, falling back to executable name")
        appid = argv_original[-1]
        if not appid.endswith(".exe"):
            panic("could not find a valid Windows executable name")
    info("launching app with id " + str(appid) + "...")
    return appid

def isnewer(ver):
    versionfile = join(LAUNCHERHOME, "opentrack-version.txt")
    if not isfile(versionfile):
        with open(versionfile, mode="w") as f:
            f.write(ver)
        return True
    with open(versionfile, mode="r+") as f:
        fver = f.read()
        return fver != ver

def updateversionfile(ver):
    versionfile = join(LAUNCHERHOME, "opentrack-version.txt")
    with open(versionfile, mode="w") as f:
        f.write(ver)

def removeversionfile():
    versionfile = join(LAUNCHERHOME, "opentrack-version.txt")
    if isfile(versionfile):
        remove(versionfile)

def dlopentrack():
    info("checking if opentrack is up to date...")
    try:
        content = urlopen(OPENTRACKURL).read().decode("UTF-8")
        latest = json.loads(content)
    except Exception as e:
        error("could not get opentrack release manifest: " + str(e))
        return

    version = latest["tag_name"].split("-")[1]
    if isnewer(version):
        info("downloading the latest opentrack version...")
        for asset in latest["assets"]:
            if asset["name"].endswith("portable.7z"):
                opentrackark = join(LAUNCHERHOME, "opentrack.7z")
                urlretrieve(asset["browser_download_url"], opentrackark)
                opentrackinstall = join(LAUNCHERHOME, "install")
                if isdir(opentrackinstall):
                    rmtree(opentrackinstall)
                err = Popen([which(ZIPBINARY), "x", "-aoa", "-o" + LAUNCHERHOME, opentrackark], cwd=LAUNCHERHOME).wait()
                remove(opentrackark)
                if err != 0:
                    panic("failed to extract 7z")
    updateversionfile(version)

def getopentrack():
    if not args.opentrack:
        return None
    dlopentrack()
    opentrackexec = join(LAUNCHERHOME, "install/opentrack.exe")
    return opentrackexec if isfile(opentrackexec) else None

def getsimhub():
    if not args.simhub:
        return None

    simhub_pfx_path = join(args.simhub_pfx, args.simhub_appid, "pfx/drive_c")

    possible_paths = [
        join(simhub_pfx_path, "program files/SimHub", args.simhub_exe),
        join(simhub_pfx_path, "Program Files (x86)/SimHub", args.simhub_exe),
        join(simhub_pfx_path, "users/steamuser/Desktop/SimHub", args.simhub_exe),
    ]

    for path in possible_paths:
        if isfile(path):
            info(f"Found SimHub at: {path}")
            return path

    error(f"Could not find SimHub executable for AppID {args.simhub_appid}")
    return None

def towinepath(p):
    if p is None: return ""
    return "Z:" + abspath(p).replace("/", "\\")

def findappcmdline():
    cmdline = ""
    for arg in reversed(argv_original):
        cmdline = arg + " " + cmdline
        if arg.endswith(".exe"): break
    return cmdline.strip()

def getlaunchscript(appid, opentrackexec):
    global PROTONBRIDGE
    scripts = join(LAUNCHERHOME, "scripts")
    if not isdir(scripts): makedirs(scripts, exist_ok=True)
    script = join(scripts, appid + ".bat")

    appcmdline = findappcmdline()
    appsplitindex = appcmdline.index(".exe") + len(".exe")
    appexec = appcmdline[:appsplitindex]
    appargs = appcmdline[appsplitindex:]
    app_exe_name = Path(appexec).name

    PROTONBRIDGE = join( SIMSHM, Path(appexec).name )

    appwine = towinepath(appexec)
    opentrackwine = towinepath(opentrackexec)
    acbridgewine = towinepath(ACSIMSHMBRIDGE)
    pc2bridgewine = towinepath(PC2SIMSHMBRIDGE)

    lines = []

    if args.acbridge:
        lines.append(f"start \"\" \"{acbridgewine}\"\r\n")

    if args.pc2bridge:
        lines.append(f"start \"\" \"{pc2bridgewine}\"\r\n")

    if opentrackexec:
        lines.append(f"start \"\" \"{opentrackwine}\"\r\n")

    # 2. Launch Logic (Conditional on pc2bridge)
    if args.pc2bridge:
        # ASYNC Launch for AMS2/PCars2
        lines.append(f"start \"\" \"{appwine}\" {appargs}\r\n")
        # Apparently no pause.exe in wine?
        lines.append("ping -n 7 127.0.0.1 >nul\r\n")
        
        # MONITORING LOOP
        lines.append(":LOOP\r\n")
        lines.append("ping -n 7 127.0.0.1 >nul\r\n")
        lines.append("set STILL_RUNNING=0\r\n")
        
        # Check original and AVX variant
        lines.append(f"tasklist /FI \"IMAGENAME eq {app_exe_name}\" 2>NUL | findstr /I /C:\"{app_exe_name}\"\r\n")
        lines.append("if %ERRORLEVEL% EQU 0 set STILL_RUNNING=1\r\n")
        
        avx_exe = app_exe_name.replace(".exe", "AVX.exe")
        lines.append(f"tasklist /FI \"IMAGENAME eq {avx_exe}\" 2>NUL | findstr /I /C:\"{avx_exe}\" \r\n")
        lines.append("if %ERRORLEVEL% EQU 0 set STILL_RUNNING=1\r\n")
        
        lines.append("if %STILL_RUNNING% EQU 1 goto LOOP\r\n")
    else:
        # STANDARD SYNC Launch for everything else
        lines.append(f"start /wait \"\" \"{appwine}\" {appargs}\r\n")

    if opentrackexec:
        lines.append("taskkill /IM opentrack.exe /F >nul 2>&1\r\n")

    if args.acbridge:
        lines.append("taskkill /IM acbridge.exe /F >nul 2>&1\r\n")

    if args.pc2bridge:
        lines.append("taskkill /IM pcars2bridge.exe /F >nul 2>&1\r\n")

    if args.lookpilot:
        lines.append("taskkill /IM start.exe /F >nul 2>&1\r\n")
        lines.append("taskkill /IM TrackIR.exe /F >nul 2>&1\r\n")

    with open(script, mode="w") as f:
        f.writelines(lines)
    return script

def makehome():
    if not isdir(LAUNCHERHOME):
        makedirs(LAUNCHERHOME, exist_ok=True)

def check7z():
    global ZIPBINARY
    ZIPBINARY = which("7z") or which("7za")
    if not ZIPBINARY: panic("7z is not installed")

def kill_process_tree(pid, timeout=5):
    """
    Kills a process and all its children gracefully, then forcefully if needed.
    Returns True if successful, False otherwise.
    """
    try:
        # Try graceful SIGTERM first
        os.killpg(os.getpgid(pid), signal.SIGTERM)
        
        # Wait for process to exit
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                os.killpg(os.getpgid(pid), 0)  # Check if group still exists
                time.sleep(0.1)
            except ProcessLookupError:
                return True  # Process group is gone
        
        # If still running, force kill
        info(f"Process {pid} didn't exit gracefully, forcing SIGKILL")
        os.killpg(os.getpgid(pid), signal.SIGKILL)
        return True
    except ProcessLookupError:
        return True  # Already dead
    except Exception as e:
        error(f"Error killing process {pid}: {e}")
        return False

def kill_by_name(name, force=False):
    """
    Kill processes by name. Uses pkill with proper error handling.
    Returns True if at least one process was found and killed.
    """
    try:
        # First check if any processes exist
        check_cmd = ["pgrep", "-f", name]
        result = subprocess.run(check_cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            # No processes found
            return False
        
        pids = result.stdout.strip().split('\n')
        info(f"Found {len(pids)} process(es) matching '{name}': {', '.join(pids)}")
        
        # Kill processes
        signal_flag = "-9" if force else "-TERM"
        kill_cmd = ["pkill", signal_flag, "-f", name]
        subprocess.run(kill_cmd, capture_output=True)
        
        # Wait a bit and verify
        time.sleep(0.5)
        verify_result = subprocess.run(check_cmd, capture_output=True)
        
        if verify_result.returncode == 0 and not force:
            # Processes still running, try force kill
            info(f"Processes still running, forcing kill for '{name}'")
            subprocess.run(["pkill", "-9", "-f", name], capture_output=True)
            time.sleep(0.5)
        
        return True
    except Exception as e:
        error(f"Error killing processes by name '{name}': {e}")
        return False

if __name__ == '__main__':
    check7z()
    makehome()

    appid = findappid()
    opentrackexec = getopentrack()
    simhubexec = getsimhub()

    launcherscript = getlaunchscript(appid, opentrackexec)

    lookpilot_proc = None
    if args.lookpilot:
        info("Launching LookPilot...")
        lookpilot_proc = Popen(["steam", "steam://rungameid/3326890"])

    # 1. Start ACSIMSHM (Native Linux) in its own process group
    ac_shm_proc = None
    if args.acbridge:
        info("Launching AC Bridge (Native)")
        # Use start_new_session instead of setpgrp for better process isolation
        ac_shm_proc = Popen(ACSIMSHM, start_new_session=True, 
                           stdout=DEVNULL, stderr=DEVNULL)

    # 2. Start PC2SIMSHM (Native Linux) in its own process group
    pc2_shm_proc = None
    if args.pc2bridge:
        info("Launching PC2 Bridge (Native)")
        pc2_shm_proc = Popen(PC2SIMSHM, start_new_session=True,
                            stdout=DEVNULL, stderr=DEVNULL)

    # 3. Prepare and launch the main game
    final_argv = list(argv_original)
    for i in range(len(final_argv) - 1, -1, -1):
        if final_argv[i].endswith(".exe"):
            final_argv[i] = launcherscript
            break

    info(f"Final execution command: {' '.join(final_argv[1:])}")
    main_game_proc = Popen(final_argv[1:])

    # 4. Launch SimHub and Proton Bridge
    bridge_proc = None
    simhub_proc = None
    if args.simhub and simhubexec:
        pt_launcher = which("protontricks-launch")
        if pt_launcher:
            clean_env = environ.copy()
            for var in ["LD_LIBRARY_PATH", "PYTHONPATH", "PYTHONHOME", "STEAM_RUNTIME_LIBRARY_PATH"]:
                clean_env.pop(var, None)

            if os.path.exists(PROTONBRIDGE):
                os.remove(PROTONBRIDGE)

            if args.acbridge:
                os.link(ACSIMSHMBRIDGE, PROTONBRIDGE)
            else:
                os.link(PC2SIMSHMBRIDGE, PROTONBRIDGE)

            info(f"Launching Proton Bridge for SimHub: {PROTONBRIDGE}")
            # Store bridge_proc so we can track it properly
            bridge_proc = Popen([pt_launcher, "--appid", str(args.simhub_appid), PROTONBRIDGE],
                env=clean_env, start_new_session=True,
                stdout=DEVNULL, stderr=DEVNULL)

            # Give bridge a moment to start
            time.sleep(1)

            info(f"Launching SimHub: {args.simhub_exe}")
            simhub_proc = Popen([pt_launcher, "--appid", str(args.simhub_appid), simhubexec],
                  env=clean_env, start_new_session=True,
                  stdout=DEVNULL, stderr=DEVNULL)

    # 5. Launch Monocoque
    monocoque_proc = None
    if args.monocoque:
        info("Launching Monocoque")
        
        monocoque_proc = Popen(["monocoque", "play"], 
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                text=True,
                                bufsize=1)

        # Give it a moment to start properly
        time.sleep(0.5)
        monocoque_proc.stdin.close()

        # Check if it started successfully
        if monocoque_proc.poll() is not None:
            error(f"Monocoque exited immediately with code {monocoque_proc.returncode}")
        else:
            info(f"Monocoque started successfully (PID: {monocoque_proc.pid})")

    # --- THE CLEANUP LOGIC ---
    try:
        info("Waiting for main game to exit...")
        main_game_proc.wait()
    except KeyboardInterrupt:
        info("Shutdown requested via keyboard...")
    finally:
        info("Main game closed. Initiating global cleanup...")

        # A. Kill Native Linux Bridge Groups
        if ac_shm_proc:
            info("Terminating AC Bridge...")
            kill_process_tree(ac_shm_proc.pid)
            
            # Clean up shm files
            info("Cleaning up AC shm files")
            for shm_file in ["/dev/shm/acpmf_crewchief", "/dev/shm/acpmf_graphics", 
                           "/dev/shm/acpmf_physics", "/dev/shm/acpmf_static"]:
                try:
                    if os.path.exists(shm_file):
                        os.remove(shm_file)
                except Exception as e:
                    error(f"Failed to remove {shm_file}: {e}")
         
        if pc2_shm_proc:
            info("Terminating PC2 Bridge...")
            kill_process_tree(pc2_shm_proc.pid)

        # B. Kill Monocoque
        if monocoque_proc:
            info("Terminating Monocoque...")
            if monocoque_proc.poll() is None:  # Still running
                # kill_process_tree(monocoque_proc.pid)
                monocoque_proc.kill()
            else:
                info(f"Monocoque already exited with code {monocoque_proc.returncode}")

        # C. Kill SimHub and Bridge processes
        if args.simhub:
            info("Terminating SimHub...")
            kill_by_name("SimHubWPF.exe")
            
            # FIX: Kill bridge by PID first if we have it, then by name as backup
            if bridge_proc and bridge_proc.poll() is None:
                info(f"Terminating Proton Bridge (PID: {bridge_proc.pid})...")
                try:
                    bridge_proc.terminate()
                    bridge_proc.wait(timeout=3)
                    info("Bridge terminate successful")
                except subprocess.TimeoutExpired:
                    info("Bridge didn't exit, force killing...")
                    bridge_proc.kill()
                    bridge_proc.wait()
                except Exception as e:
                    error(f"Error terminating bridge: {e}")
            
            # # Backup: kill by bridge executable name
            # if PROTONBRIDGE:
            #     bridge_name = Path(PROTONBRIDGE).name
            #     info(f"Ensuring proton bridge {bridge_name} is terminated...")
            #     kill_by_name(bridge_name, force=True)

        # D. Kill other Windows/Wine executables by name
        targets = [
            "acbridge.exe",
            "pcars2bridge.exe",
            "opentrack.exe",
            "TrackIR.exe",
        ]

        for exe in targets:
            if kill_by_name(exe):
                info(f"Terminated {exe}")

        # E. Kill LookPilot
        if args.lookpilot:
            info("Terminating LookPilot...")
            kill_by_name("LookPilot")

        # F. Remove the hardlink
        if PROTONBRIDGE and os.path.exists(PROTONBRIDGE):
            try:
                info(f"Cleaning up {PROTONBRIDGE}")
                os.remove(PROTONBRIDGE)
                info("Cleaned up bridge link.")
            except Exception as e:
                error(f"Failed to clean up {PROTONBRIDGE}: {e}")

    info("Cleanup complete. Exiting.")